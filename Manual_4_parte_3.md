# üìö MANUAL 3 - PARTE 3: CONTROLLERS Y RUTAS API

## üìã INFORMACI√ìN DEL MANUAL

**Proyecto:** Sistema E-commerce Tecnol√≥gico - Manual 3 (Parte 3/4)  
**Prerequisito:** Manual 3 Parte 2 completado (Modelos creados)  
**Tiempo Estimado:** 60 minutos  
**Sesi√≥n del Cronograma:** 3 (MongoDB + Base de datos)  
**Estado:** MANUAL COMPLETO PASO A PASO ‚úÖ

---

## ‚ö†Ô∏è REQUISITOS PREVIOS

- ‚úÖ **Manual 3 - Parte 2** completado exitosamente
- ‚úÖ **Carpeta models/** con Product.js, User.js, Order.js, index.js
- ‚úÖ **MongoDB Atlas** conectado y funcionando
- ‚úÖ **server-simple.js** funcionando con productos
- ‚úÖ **Frontend** cargando productos correctamente
- ‚úÖ **Visual Studio Code** abierto en la carpeta del proyecto

---

## üéØ OBJETIVOS DE LA PARTE 3

**CREAR:** Arquitectura profesional con Controllers y Rutas API

**AL FINALIZAR ESTA PARTE TENDR√ÅS:**
- üèóÔ∏è **Controllers profesionales** para Product, User, Order
- üõ§Ô∏è **Rutas API REST** completas organizadas
- üîÑ **Migraci√≥n de server-simple.js** a arquitectura profesional
- üõ°Ô∏è **Manejo de errores** robusto
- ‚úÖ **APIs funcionando** sin romper el frontend

---

## üìÖ PLAN DE TRABAJO (60 MINUTOS)

### **FASE 1: CREAR CONTROLLERS** (20 minutos)
- Product Controller con m√©todos CRUD
- User Controller preparado para autenticaci√≥n
- Order Controller para sistema de pedidos

### **FASE 2: CREAR RUTAS** (20 minutos)
- Routes organizadas por m√≥dulo
- Middleware de validaci√≥n
- Estructura REST profesional

### **FASE 3: MIGRACI√ìN GRADUAL** (20 minutos)
- Actualizar server.js principal
- Preservar funcionalidad actual
- Testing completo

---

## üèóÔ∏è FASE 1: CREAR CONTROLLERS (20 MINUTOS)

### **PASO 1.1: Crear carpeta controllers**

#### **1.1.1 Crear directorio**
```bash
cd backend
mkdir controllers
```

#### **1.1.2 Verificar creaci√≥n**
```bash
# Windows
dir controllers

# Linux/Mac
ls -la controllers
```

### **PASO 1.2: Crear Product Controller**

#### **1.2.1 Crear controllers/productController.js**
**Crear archivo:** `backend/controllers/productController.js`

**PEGAR este contenido completo:**

```javascript
const { Product } = require('../models');

// @desc    Obtener todos los productos
// @route   GET /api/products
// @access  Public
const getAllProducts = async (req, res) => {
  try {
    const products = await Product.find({});
    
    // Transformar productos para incluir ID num√©rico compatible con frontend
    const productsWithNumericId = products.map((product, index) => ({
      id: index + 1, // ID num√©rico secuencial (1, 2, 3...)
      _id: product._id, // Mantener _id original para referencias internas
      name: product.name,
      price: product.price,
      image: product.image,
      images: product.images || [product.image],
      category: product.category,
      description: product.description,
      features: product.features || [],
      specifications: product.specifications || {},
      stock: product.stock,
      rating: product.rating,
      reviewCount: product.reviewCount,
      slug: product.slug,
      createdAt: product.createdAt,
      updatedAt: product.updatedAt
    }));
    
    console.log(`üì¶ Enviando ${productsWithNumericId.length} productos al frontend`);
    res.json(productsWithNumericId);
  } catch (error) {
    console.error('‚ùå Error obteniendo productos:', error.message);
    res.status(500).json({ 
      error: 'Error del servidor', 
      message: 'No se pudieron obtener los productos' 
    });
  }
};

// @desc    Obtener un producto por ID
// @route   GET /api/products/:id
// @access  Public
const getProductById = async (req, res) => {
  try {
    const productId = parseInt(req.params.id);
    
    // Obtener todos los productos y encontrar por √≠ndice
    const allProducts = await Product.find({});
    const product = allProducts[productId - 1]; // ID 1 = √≠ndice 0, ID 2 = √≠ndice 1, etc.
    
    if (!product) {
      return res.status(404).json({
        error: 'Producto no encontrado',
        message: `No se encontr√≥ el producto con ID ${productId}`
      });
    }
    
    // Transformar producto con ID num√©rico
    const productWithNumericId = {
      id: productId,
      _id: product._id,
      name: product.name,
      price: product.price,
      image: product.image,
      images: product.images || [product.image],
      category: product.category,
      description: product.description,
      features: product.features || [],
      specifications: product.specifications || {},
      stock: product.stock,
      rating: product.rating,
      reviewCount: product.reviewCount,
      slug: product.slug,
      createdAt: product.createdAt,
      updatedAt: product.updatedAt
    };
    
    console.log(`üì¶ Enviando producto: ${product.name} (ID: ${productId})`);
    res.json(productWithNumericId);
  } catch (error) {
    console.error('‚ùå Error obteniendo producto:', error.message);
    res.status(500).json({ 
      error: 'Error del servidor', 
      message: 'No se pudo obtener el producto' 
    });
  }
};

// @desc    Crear nuevo producto
// @route   POST /api/products
// @access  Private (Admin)
const createProduct = async (req, res) => {
  try {
    const {
      name,
      description,
      price,
      image,
      images,
      category,
      features,
      specifications,
      stock,
      rating,
      reviewCount,
      slug
    } = req.body;

    // Validaciones b√°sicas
    if (!name || !description || !price || !image || !category) {
      return res.status(400).json({
        error: 'Campos requeridos faltantes',
        message: 'name, description, price, image y category son obligatorios'
      });
    }

    const product = new Product({
      name,
      description,
      price,
      image,
      images: images || [image],
      category,
      features: features || [],
      specifications: specifications || {},
      stock: stock || 10,
      rating: rating || 4.5,
      reviewCount: reviewCount || 0,
      slug: slug || name.toLowerCase().replace(/[^a-z0-9\s-]/g, '').trim().replace(/\s+/g, '-')
    });

    const savedProduct = await product.save();
    
    console.log(`‚úÖ Producto creado: ${savedProduct.name}`);
    res.status(201).json(savedProduct);
  } catch (error) {
    console.error('‚ùå Error creando producto:', error.message);
    if (error.code === 11000) {
      res.status(400).json({
        error: 'Producto duplicado',
        message: 'Ya existe un producto con ese nombre o slug'
      });
    } else {
      res.status(500).json({ 
        error: 'Error del servidor', 
        message: 'No se pudo crear el producto' 
      });
    }
  }
};

// @desc    Actualizar producto
// @route   PUT /api/products/:id
// @access  Private (Admin)
const updateProduct = async (req, res) => {
  try {
    const productId = req.params.id;
    
    // Buscar por _id de MongoDB, no por ID num√©rico
    const product = await Product.findById(productId);
    
    if (!product) {
      return res.status(404).json({
        error: 'Producto no encontrado',
        message: `No se encontr√≥ el producto con ID ${productId}`
      });
    }

    // Actualizar campos permitidos
    const updateFields = [
      'name', 'description', 'price', 'image', 'images', 
      'category', 'features', 'specifications', 'stock', 
      'rating', 'reviewCount', 'slug'
    ];
    
    updateFields.forEach(field => {
      if (req.body[field] !== undefined) {
        product[field] = req.body[field];
      }
    });

    const updatedProduct = await product.save();
    
    console.log(`‚úÖ Producto actualizado: ${updatedProduct.name}`);
    res.json(updatedProduct);
  } catch (error) {
    console.error('‚ùå Error actualizando producto:', error.message);
    res.status(500).json({ 
      error: 'Error del servidor', 
      message: 'No se pudo actualizar el producto' 
    });
  }
};

// @desc    Eliminar producto
// @route   DELETE /api/products/:id
// @access  Private (Admin)
const deleteProduct = async (req, res) => {
  try {
    const productId = req.params.id;
    
    // Buscar por _id de MongoDB
    const product = await Product.findById(productId);
    
    if (!product) {
      return res.status(404).json({
        error: 'Producto no encontrado',
        message: `No se encontr√≥ el producto con ID ${productId}`
      });
    }

    await Product.findByIdAndDelete(productId);
    
    console.log(`üóëÔ∏è Producto eliminado: ${product.name}`);
    res.json({
      message: 'Producto eliminado exitosamente',
      deletedProduct: {
        _id: product._id,
        name: product.name
      }
    });
  } catch (error) {
    console.error('‚ùå Error eliminando producto:', error.message);
    res.status(500).json({ 
      error: 'Error del servidor', 
      message: 'No se pudo eliminar el producto' 
    });
  }
};

// @desc    Buscar productos
// @route   GET /api/products/search?q=term
// @access  Public
const searchProducts = async (req, res) => {
  try {
    const { q } = req.query;
    
    if (!q || q.trim() === '') {
      return res.status(400).json({
        error: 'Par√°metro de b√∫squeda requerido',
        message: 'Proporciona un t√©rmino de b√∫squeda con ?q=t√©rmino'
      });
    }

    const searchRegex = new RegExp(q, 'i');
    
    const products = await Product.find({
      $or: [
        { name: searchRegex },
        { description: searchRegex },
        { category: searchRegex }
      ]
    });
    
    console.log(`üîç B√∫squeda "${q}": ${products.length} productos encontrados`);
    res.json(products);
  } catch (error) {
    console.error('‚ùå Error en b√∫squeda:', error.message);
    res.status(500).json({ 
      error: 'Error del servidor', 
      message: 'No se pudo realizar la b√∫squeda' 
    });
  }
};

module.exports = {
  getAllProducts,
  getProductById,
  createProduct,
  updateProduct,
  deleteProduct,
  searchProducts
};
```

### **PASO 1.3: Crear User Controller**

#### **1.3.1 Crear controllers/userController.js**
**Crear archivo:** `backend/controllers/userController.js`

**PEGAR este contenido completo:**

```javascript
const { User } = require('../models');

// @desc    Obtener perfil de usuario
// @route   GET /api/users/profile
// @access  Private
const getUserProfile = async (req, res) => {
  try {
    // req.user vendr√° del middleware de autenticaci√≥n (futuro)
    const userId = req.params.id;
    
    const user = await User.findById(userId);
    
    if (!user) {
      return res.status(404).json({
        error: 'Usuario no encontrado',
        message: 'No se encontr√≥ el usuario especificado'
      });
    }
    
    console.log(`üë§ Perfil obtenido: ${user.email}`);
    res.json(user);
  } catch (error) {
    console.error('‚ùå Error obteniendo perfil:', error.message);
    res.status(500).json({ 
      error: 'Error del servidor', 
      message: 'No se pudo obtener el perfil' 
    });
  }
};

// @desc    Registrar nuevo usuario
// @route   POST /api/users/register
// @access  Public
const registerUser = async (req, res) => {
  try {
    const {
      name,
      email,
      password,
      phone,
      address
    } = req.body;

    // Validaciones b√°sicas
    if (!name || !email || !password) {
      return res.status(400).json({
        error: 'Campos requeridos faltantes',
        message: 'name, email y password son obligatorios'
      });
    }

    // Verificar si el usuario ya existe
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({
        error: 'Usuario ya existe',
        message: 'Ya existe un usuario con ese email'
      });
    }

    // Crear nuevo usuario (el password se encripta autom√°ticamente en el modelo)
    const user = new User({
      name,
      email,
      password,
      phone: phone || '',
      address: address || {}
    });

    const savedUser = await user.save();
    
    console.log(`‚úÖ Usuario registrado: ${savedUser.email}`);
    
    // Responder sin el password
    const userResponse = {
      _id: savedUser._id,
      name: savedUser.name,
      email: savedUser.email,
      role: savedUser.role,
      createdAt: savedUser.createdAt
    };
    
    res.status(201).json({
      message: 'Usuario registrado exitosamente',
      user: userResponse
    });
  } catch (error) {
    console.error('‚ùå Error registrando usuario:', error.message);
    res.status(500).json({ 
      error: 'Error del servidor', 
      message: 'No se pudo registrar el usuario' 
    });
  }
};

// @desc    Autenticar usuario & obtener token
// @route   POST /api/users/login
// @access  Public
const loginUser = async (req, res) => {
  try {
    const { email, password } = req.body;

    // Validaciones b√°sicas
    if (!email || !password) {
      return res.status(400).json({
        error: 'Credenciales requeridas',
        message: 'email y password son obligatorios'
      });
    }

    // Buscar usuario con password (normalmente est√° excluido)
    const user = await User.findByEmailWithPassword(email);
    
    if (!user) {
      return res.status(401).json({
        error: 'Credenciales inv√°lidas',
        message: 'Email o contrase√±a incorrectos'
      });
    }

    // Verificar password
    const isPasswordValid = await user.comparePassword(password);
    
    if (!isPasswordValid) {
      return res.status(401).json({
        error: 'Credenciales inv√°lidas',
        message: 'Email o contrase√±a incorrectos'
      });
    }

    // Actualizar √∫ltimo login
    await user.updateLastLogin();
    
    console.log(`üîê Login exitoso: ${user.email}`);
    
    // TODO: Generar JWT token (implementar en futuras partes)
    const userResponse = {
      _id: user._id,
      name: user.name,
      email: user.email,
      role: user.role,
      lastLogin: user.lastLogin
    };
    
    res.json({
      message: 'Login exitoso',
      user: userResponse
      // token: generateToken(user._id) // TODO: Implementar JWT
    });
  } catch (error) {
    console.error('‚ùå Error en login:', error.message);
    res.status(500).json({ 
      error: 'Error del servidor', 
      message: 'No se pudo procesar el login' 
    });
  }
};

// @desc    Actualizar perfil de usuario
// @route   PUT /api/users/profile
// @access  Private
const updateUserProfile = async (req, res) => {
  try {
    const userId = req.params.id; // En futuro vendr√° de req.user.id
    
    const user = await User.findById(userId);
    
    if (!user) {
      return res.status(404).json({
        error: 'Usuario no encontrado',
        message: 'No se encontr√≥ el usuario especificado'
      });
    }

    // Actualizar campos permitidos (sin password aqu√≠)
    const updateFields = ['name', 'phone', 'address', 'avatar', 'newsletter', 'notifications', 'language'];
    
    updateFields.forEach(field => {
      if (req.body[field] !== undefined) {
        user[field] = req.body[field];
      }
    });

    const updatedUser = await user.save();
    
    console.log(`‚úÖ Perfil actualizado: ${updatedUser.email}`);
    res.json({
      message: 'Perfil actualizado exitosamente',
      user: updatedUser
    });
  } catch (error) {
    console.error('‚ùå Error actualizando perfil:', error.message);
    res.status(500).json({ 
      error: 'Error del servidor', 
      message: 'No se pudo actualizar el perfil' 
    });
  }
};

// @desc    Obtener todos los usuarios (Admin)
// @route   GET /api/users
// @access  Private (Admin)
const getAllUsers = async (req, res) => {
  try {
    const users = await User.find({}).select('-password');
    
    console.log(`üë• Enviando ${users.length} usuarios`);
    res.json(users);
  } catch (error) {
    console.error('‚ùå Error obteniendo usuarios:', error.message);
    res.status(500).json({ 
      error: 'Error del servidor', 
      message: 'No se pudieron obtener los usuarios' 
    });
  }
};

module.exports = {
  getUserProfile,
  registerUser,
  loginUser,
  updateUserProfile,
  getAllUsers
};
```

### **PASO 1.4: Crear Order Controller**

#### **1.4.1 Crear controllers/orderController.js**
**Crear archivo:** `backend/controllers/orderController.js`

**PEGAR este contenido completo:**

```javascript
const { Order, Product, User } = require('../models');

// @desc    Crear nueva orden
// @route   POST /api/orders
// @access  Private
const createOrder = async (req, res) => {
  try {
    const {
      userId,
      items,
      shippingAddress,
      paymentMethod
    } = req.body;

    // Validaciones b√°sicas
    if (!userId || !items || !items.length || !shippingAddress) {
      return res.status(400).json({
        error: 'Campos requeridos faltantes',
        message: 'userId, items y shippingAddress son obligatorios'
      });
    }

    // Verificar que el usuario existe
    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({
        error: 'Usuario no encontrado',
        message: 'El usuario especificado no existe'
      });
    }

    // Validar y procesar items
    let subtotalAmount = 0;
    const processedItems = [];

    for (const item of items) {
      const product = await Product.findById(item.productId);
      
      if (!product) {
        return res.status(404).json({
          error: 'Producto no encontrado',
          message: `Producto con ID ${item.productId} no existe`
        });
      }

      if (product.stock < item.quantity) {
        return res.status(400).json({
          error: 'Stock insuficiente',
          message: `Solo hay ${product.stock} unidades de ${product.name}`
        });
      }

      const itemSubtotal = product.price * item.quantity;
      subtotalAmount += itemSubtotal;

      processedItems.push({
        product: product._id,
        name: product.name,
        image: product.image,
        price: product.price,
        quantity: item.quantity,
        subtotal: itemSubtotal
      });

      // Reducir stock
      product.stock -= item.quantity;
      await product.save();
    }

    // Calcular totales
    const shippingCost = subtotalAmount > 50 ? 0 : 10; // Env√≠o gratis sobre $50
    const tax = subtotalAmount * 0.16; // 16% de impuestos
    const totalAmount = subtotalAmount + shippingCost + tax;

    // Generar n√∫mero de orden √∫nico
    const orderNumber = `ORD-${Date.now()}-${Math.random().toString(36).substr(2, 5).toUpperCase()}`;

    const order = new Order({
      orderNumber,
      user: userId,
      items: processedItems,
      subtotalAmount,
      shippingCost,
      tax,
      totalAmount,
      shippingAddress,
      paymentMethod: paymentMethod || 'pending'
    });

    const savedOrder = await order.save();
    await savedOrder.populate('user', 'name email');
    await savedOrder.populate('items.product', 'name image');
    
    console.log(`‚úÖ Orden creada: ${savedOrder.orderNumber} - $${totalAmount}`);
    res.status(201).json(savedOrder);
  } catch (error) {
    console.error('‚ùå Error creando orden:', error.message);
    res.status(500).json({ 
      error: 'Error del servidor', 
      message: 'No se pudo crear la orden' 
    });
  }
};

// @desc    Obtener √≥rdenes del usuario
// @route   GET /api/orders/user/:userId
// @access  Private
const getUserOrders = async (req, res) => {
  try {
    const userId = req.params.userId;
    
    const orders = await Order.find({ user: userId })
      .populate('items.product', 'name image')
      .sort({ createdAt: -1 });
    
    console.log(`üì¶ Enviando ${orders.length} √≥rdenes del usuario ${userId}`);
    res.json(orders);
  } catch (error) {
    console.error('‚ùå Error obteniendo √≥rdenes:', error.message);
    res.status(500).json({ 
      error: 'Error del servidor', 
      message: 'No se pudieron obtener las √≥rdenes' 
    });
  }
};

// @desc    Obtener orden por ID
// @route   GET /api/orders/:id
// @access  Private
const getOrderById = async (req, res) => {
  try {
    const orderId = req.params.id;
    
    const order = await Order.findById(orderId)
      .populate('user', 'name email phone')
      .populate('items.product', 'name image description');
    
    if (!order) {
      return res.status(404).json({
        error: 'Orden no encontrada',
        message: `No se encontr√≥ la orden con ID ${orderId}`
      });
    }
    
    console.log(`üìã Enviando orden: ${order.orderNumber}`);
    res.json(order);
  } catch (error) {
    console.error('‚ùå Error obteniendo orden:', error.message);
    res.status(500).json({ 
      error: 'Error del servidor', 
      message: 'No se pudo obtener la orden' 
    });
  }
};

// @desc    Actualizar estado de orden
// @route   PUT /api/orders/:id/status
// @access  Private (Admin)
const updateOrderStatus = async (req, res) => {
  try {
    const orderId = req.params.id;
    const { status, trackingNumber } = req.body;
    
    const order = await Order.findById(orderId);
    
    if (!order) {
      return res.status(404).json({
        error: 'Orden no encontrada',
        message: `No se encontr√≥ la orden con ID ${orderId}`
      });
    }

    // Validar estado v√°lido
    const validStatuses = ['pending', 'confirmed', 'processing', 'shipped', 'delivered', 'cancelled'];
    if (status && !validStatuses.includes(status)) {
      return res.status(400).json({
        error: 'Estado inv√°lido',
        message: `El estado debe ser uno de: ${validStatuses.join(', ')}`
      });
    }

    // Actualizar campos
    if (status) {
      order.status = status;
      
      // Agregar al historial
      order.statusHistory.push({
        status,
        timestamp: new Date(),
        note: `Estado actualizado a ${status}`
      });
    }
    
    if (trackingNumber) {
      order.trackingNumber = trackingNumber;
    }

    const updatedOrder = await order.save();
    
    console.log(`‚úÖ Orden actualizada: ${updatedOrder.orderNumber} - ${status}`);
    res.json(updatedOrder);
  } catch (error) {
    console.error('‚ùå Error actualizando orden:', error.message);
    res.status(500).json({ 
      error: 'Error del servidor', 
      message: 'No se pudo actualizar la orden' 
    });
  }
};

// @desc    Obtener todas las √≥rdenes (Admin)
// @route   GET /api/orders
// @access  Private (Admin)
const getAllOrders = async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const skip = (page - 1) * limit;
    
    const orders = await Order.find({})
      .populate('user', 'name email')
      .populate('items.product', 'name image')
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit);
    
    const totalOrders = await Order.countDocuments();
    const totalPages = Math.ceil(totalOrders / limit);
    
    console.log(`üìä Enviando ${orders.length} √≥rdenes (p√°gina ${page}/${totalPages})`);
    res.json({
      orders,
      pagination: {
        currentPage: page,
        totalPages,
        totalOrders,
        hasNext: page < totalPages,
        hasPrev: page > 1
      }
    });
  } catch (error) {
    console.error('‚ùå Error obteniendo √≥rdenes:', error.message);
    res.status(500).json({ 
      error: 'Error del servidor', 
      message: 'No se pudieron obtener las √≥rdenes' 
    });
  }
};

// @desc    Obtener estad√≠sticas de √≥rdenes
// @route   GET /api/orders/stats
// @access  Private (Admin)
const getOrderStats = async (req, res) => {
  try {
    const totalOrders = await Order.countDocuments();
    const pendingOrders = await Order.countDocuments({ status: 'pending' });
    const completedOrders = await Order.countDocuments({ status: 'delivered' });
    
    // Ventas totales
    const salesResult = await Order.aggregate([
      { $match: { status: { $ne: 'cancelled' } } },
      { $group: { _id: null, totalSales: { $sum: '$totalAmount' } } }
    ]);
    const totalSales = salesResult.length > 0 ? salesResult[0].totalSales : 0;
    
    // Ventas por mes (√∫ltimos 12 meses)
    const monthlyStats = await Order.aggregate([
      {
        $match: {
          createdAt: { $gte: new Date(Date.now() - 365 * 24 * 60 * 60 * 1000) }
        }
      },
      {
        $group: {
          _id: {
            year: { $year: '$createdAt' },
            month: { $month: '$createdAt' }
          },
          orders: { $sum: 1 },
          revenue: { $sum: '$totalAmount' }
        }
      },
      { $sort: { '_id.year': 1, '_id.month': 1 } }
    ]);
    
    const stats = {
      totalOrders,
      pendingOrders,
      completedOrders,
      totalSales: totalSales.toFixed(2),
      averageOrderValue: totalOrders > 0 ? (totalSales / totalOrders).toFixed(2) : 0,
      monthlyStats
    };
    
    console.log(`üìà Estad√≠sticas generadas: ${totalOrders} √≥rdenes, $${totalSales}`);
    res.json(stats);
  } catch (error) {
    console.error('‚ùå Error obteniendo estad√≠sticas:', error.message);
    res.status(500).json({ 
      error: 'Error del servidor', 
      message: 'No se pudieron obtener las estad√≠sticas' 
    });
  }
};

module.exports = {
  createOrder,
  getUserOrders,
  getOrderById,
  updateOrderStatus,
  getAllOrders,
  getOrderStats
};
```

---

## üõ§Ô∏è FASE 2: CREAR RUTAS (20 MINUTOS)

### **PASO 2.1: Crear carpeta routes**

#### **2.1.1 Crear directorio**
```bash
cd backend
mkdir routes
```

#### **2.1.2 Verificar creaci√≥n**
```bash
# Windows
dir routes

# Linux/Mac
ls -la routes
```

### **PASO 2.2: Crear Product Routes**

#### **2.2.1 Crear routes/productRoutes.js**
**Crear archivo:** `backend/routes/productRoutes.js`

**PEGAR este contenido completo:**

```javascript
const express = require('express');
const router = express.Router();
const {
  getAllProducts,
  getProductById,
  createProduct,
  updateProduct,
  deleteProduct,
  searchProducts
} = require('../controllers/productController');

// @route   GET /api/products
// @desc    Obtener todos los productos
// @access  Public
router.get('/', getAllProducts);

// @route   GET /api/products/search
// @desc    Buscar productos
// @access  Public
router.get('/search', searchProducts);

// @route   GET /api/products/:id
// @desc    Obtener producto por ID
// @access  Public
router.get('/:id', getProductById);

// @route   POST /api/products
// @desc    Crear nuevo producto
// @access  Private (Admin)
router.post('/', createProduct);

// @route   PUT /api/products/:id
// @desc    Actualizar producto
// @access  Private (Admin)
router.put('/:id', updateProduct);

// @route   DELETE /api/products/:id
// @desc    Eliminar producto
// @access  Private (Admin)
router.delete('/:id', deleteProduct);

module.exports = router;
```

### **PASO 2.3: Crear User Routes**

#### **2.3.1 Crear routes/userRoutes.js**
**Crear archivo:** `backend/routes/userRoutes.js`

**PEGAR este contenido completo:**

```javascript
const express = require('express');
const router = express.Router();
const {
  getUserProfile,
  registerUser,
  loginUser,
  updateUserProfile,
  getAllUsers
} = require('../controllers/userController');

// @route   POST /api/users/register
// @desc    Registrar nuevo usuario
// @access  Public
router.post('/register', registerUser);

// @route   POST /api/users/login
// @desc    Autenticar usuario
// @access  Public
router.post('/login', loginUser);

// @route   GET /api/users
// @desc    Obtener todos los usuarios (Admin)
// @access  Private (Admin)
router.get('/', getAllUsers);

// @route   GET /api/users/:id
// @desc    Obtener perfil de usuario
// @access  Private
router.get('/:id', getUserProfile);

// @route   PUT /api/users/:id
// @desc    Actualizar perfil de usuario
// @access  Private
router.put('/:id', updateUserProfile);

module.exports = router;
```

### **PASO 2.4: Crear Order Routes**

#### **2.4.1 Crear routes/orderRoutes.js**
**Crear archivo:** `backend/routes/orderRoutes.js`

**PEGAR este contenido completo:**

```javascript
const express = require('express');
const router = express.Router();
const {
  createOrder,
  getUserOrders,
  getOrderById,
  updateOrderStatus,
  getAllOrders,
  getOrderStats
} = require('../controllers/orderController');

// @route   POST /api/orders
// @desc    Crear nueva orden
// @access  Private
router.post('/', createOrder);

// @route   GET /api/orders
// @desc    Obtener todas las √≥rdenes (Admin)
// @access  Private (Admin)
router.get('/', getAllOrders);

// @route   GET /api/orders/stats
// @desc    Obtener estad√≠sticas de √≥rdenes
// @access  Private (Admin)
router.get('/stats', getOrderStats);

// @route   GET /api/orders/user/:userId
// @desc    Obtener √≥rdenes del usuario
// @access  Private
router.get('/user/:userId', getUserOrders);

// @route   GET /api/orders/:id
// @desc    Obtener orden por ID
// @access  Private
router.get('/:id', getOrderById);

// @route   PUT /api/orders/:id/status
// @desc    Actualizar estado de orden
// @access  Private (Admin)
router.put('/:id/status', updateOrderStatus);

module.exports = router;
```

### **PASO 2.5: Crear Middleware de Error**

#### **2.5.1 Crear carpeta middleware**
```bash
mkdir middleware
```

#### **2.5.2 Crear middleware/errorHandler.js**
**Crear archivo:** `backend/middleware/errorHandler.js`

**PEGAR este contenido completo:**

```javascript
// Middleware de manejo de errores personalizado
const errorHandler = (err, req, res, next) => {
  console.error('üî• Error capturado:', err);

  // Error de validaci√≥n de Mongoose
  if (err.name === 'ValidationError') {
    const errors = Object.values(err.errors).map(error => error.message);
    return res.status(400).json({
      error: 'Error de validaci√≥n',
      message: 'Los datos proporcionados no son v√°lidos',
      details: errors
    });
  }

  // Error de duplicado (c√≥digo 11000)
  if (err.code === 11000) {
    const field = Object.keys(err.keyValue)[0];
    return res.status(400).json({
      error: 'Valor duplicado',
      message: `El ${field} ya existe`,
      field
    });
  }

  // Error de cast (ID inv√°lido)
  if (err.name === 'CastError') {
    return res.status(400).json({
      error: 'ID inv√°lido',
      message: 'El ID proporcionado no tiene un formato v√°lido'
    });
  }

  // Error por defecto
  res.status(err.statusCode || 500).json({
    error: err.name || 'Error del servidor',
    message: err.message || 'Ha ocurrido un error interno del servidor',
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
  });
};

// Middleware para manejar rutas no encontradas
const notFound = (req, res, next) => {
  const error = new Error(`Ruta no encontrada: ${req.originalUrl}`);
  error.statusCode = 404;
  next(error);
};

module.exports = {
  errorHandler,
  notFound
};
```

---

## üîÑ FASE 3: MIGRACI√ìN GRADUAL (20 MINUTOS)

### **PASO 3.1: Actualizar server.js principal**

#### **3.1.1 Crear backup del server-simple.js**
```bash
# Crear copia de seguridad
copy server-simple.js server-simple-backup.js  # Windows
cp server-simple.js server-simple-backup.js    # Linux/Mac
```

#### **3.1.2 Crear nuevo server.js profesional**
**Crear archivo:** `backend/server.js` (reemplazar el existente si lo hay)

**PEGAR este contenido completo:**

```javascript
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const mongoose = require('mongoose');

// Importar rutas
const productRoutes = require('./routes/productRoutes');
const userRoutes = require('./routes/userRoutes');
const orderRoutes = require('./routes/orderRoutes');

// Importar middleware
const { errorHandler, notFound } = require('./middleware/errorHandler');

const app = express();
const PORT = process.env.PORT || 5000;

// Conectar a MongoDB Atlas
async function connectDB() {
  try {
    await mongoose.connect(process.env.MONGODB_URI);
    console.log('üóÑÔ∏è  MongoDB Atlas conectado exitosamente!');
    console.log('üåç Host:', mongoose.connection.host);
    console.log('üìä Base de datos:', mongoose.connection.name);
    console.log('üîó Puerto:', mongoose.connection.port);
  } catch (error) {
    console.error('‚ùå Error conectando a MongoDB:', error.message);
    process.exit(1);
  }
}

// Conectar a base de datos
connectDB();

// Middleware global
app.use(cors());
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ extended: true, limit: '50mb' }));

// Middleware de logging
app.use((req, res, next) => {
  console.log(`${req.method} ${req.path} - ${new Date().toISOString()}`);
  next();
});

// Ruta ra√≠z
app.get('/', (req, res) => {
  res.json({ 
    message: 'üõí E-commerce API funcionando!',
    version: '3.0.0',
    timestamp: new Date().toISOString(),
    database: mongoose.connection.readyState === 1 ? 'Conectado ‚úÖ' : 'Desconectado ‚ùå',
    endpoints: {
      products: '/api/products',
      users: '/api/users', 
      orders: '/api/orders',
      health: '/health',
      dbInfo: '/api/db-info'
    }
  });
});

// Rutas API
app.use('/api/products', productRoutes);
app.use('/api/users', userRoutes);
app.use('/api/orders', orderRoutes);

// Rutas de health check (mantener compatibilidad)
app.get('/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    database: mongoose.connection.readyState === 1 ? 'MongoDB Atlas conectado ‚úÖ' : 'MongoDB Atlas desconectado ‚ùå',
    environment: process.env.NODE_ENV || 'development',
    port: PORT,
    version: '3.0.0'
  });
});

app.get('/api/db-info', async (req, res) => {
  try {
    if (mongoose.connection.readyState === 1) {
      // Importar modelos para contar documentos
      const { Product, User, Order } = require('./models');
      
      const productCount = await Product.countDocuments();
      const userCount = await User.countDocuments();
      const orderCount = await Order.countDocuments();
      
      res.json({
        connected: true,
        database: mongoose.connection.name,
        host: mongoose.connection.host,
        port: mongoose.connection.port,
        readyState: mongoose.connection.readyState,
        readyStateText: 'Connected to MongoDB Atlas',
        collections: {
          products: productCount,
          users: userCount,
          orders: orderCount
        }
      });
    } else {
      res.status(500).json({
        connected: false,
        readyState: mongoose.connection.readyState,
        readyStateText: 'Disconnected from MongoDB Atlas'
      });
    }
  } catch (error) {
    res.status(500).json({
      error: 'Error obteniendo informaci√≥n de la base de datos',
      message: error.message
    });
  }
});

// Middleware de error (debe ir al final)
app.use(notFound);
app.use(errorHandler);

// Inicializar servidor
app.listen(PORT, () => {
  console.log('='.repeat(50));
  console.log('üöÄ SERVIDOR E-COMMERCE INICIADO');
  console.log('='.repeat(50));
  console.log(`üì° Puerto: ${PORT}`);
  console.log(`üåê URL: http://localhost:${PORT}`);
  console.log(`üìä API Productos: http://localhost:${PORT}/api/products`);
  console.log(`üë• API Usuarios: http://localhost:${PORT}/api/users`);
  console.log(`üõí API √ìrdenes: http://localhost:${PORT}/api/orders`);
  console.log(`‚ù§Ô∏è  Health Check: http://localhost:${PORT}/health`);
  console.log(`üìà DB Info: http://localhost:${PORT}/api/db-info`);
  console.log('='.repeat(50));
  console.log('‚úÖ Servidor listo para recibir peticiones');
});

// Manejo graceful de cierre
process.on('SIGTERM', async () => {
  console.log('üîÑ Cerrando servidor...');
  await mongoose.connection.close();
  process.exit(0);
});

process.on('SIGINT', async () => {
  console.log('üîÑ Cerrando servidor...');
  await mongoose.connection.close();
  process.exit(0);
});
```

### **PASO 3.2: Verificar estructura completa**

#### **3.2.1 Verificar archivos creados**
```bash
# En terminal backend
ls -la
```

**Deber√≠as tener:**
```
backend/
‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îú‚îÄ‚îÄ productController.js ‚úÖ
‚îÇ   ‚îú‚îÄ‚îÄ userController.js ‚úÖ
‚îÇ   ‚îî‚îÄ‚îÄ orderController.js ‚úÖ
‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îî‚îÄ‚îÄ errorHandler.js ‚úÖ
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îú‚îÄ‚îÄ index.js ‚úÖ
‚îÇ   ‚îú‚îÄ‚îÄ Product.js ‚úÖ
‚îÇ   ‚îú‚îÄ‚îÄ User.js ‚úÖ
‚îÇ   ‚îî‚îÄ‚îÄ Order.js ‚úÖ
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ productRoutes.js ‚úÖ
‚îÇ   ‚îú‚îÄ‚îÄ userRoutes.js ‚úÖ
‚îÇ   ‚îî‚îÄ‚îÄ orderRoutes.js ‚úÖ
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ database.js
‚îú‚îÄ‚îÄ .env ‚úÖ
‚îú‚îÄ‚îÄ server.js ‚úÖ (nuevo profesional)
‚îú‚îÄ‚îÄ server-simple.js ‚úÖ (backup funcionando)
‚îú‚îÄ‚îÄ server-simple-backup.js ‚úÖ (copia seguridad)
‚îî‚îÄ‚îÄ seed-products.js ‚úÖ
```

### **PASO 3.3: Probar el nuevo servidor**

#### **3.3.1 Detener servidor actual**
```bash
# En terminal donde corre server-simple.js
Ctrl + C
```

#### **3.3.2 Iniciar nuevo servidor profesional**
```bash
# En terminal backend
npx nodemon server.js
```

**Deber√≠as ver:**
```bash
üóÑÔ∏è  MongoDB Atlas conectado exitosamente!
üåç Host: ac-7cd2lsu-shard-00-01.mx7lpcr.mongodb.net
üìä Base de datos: ecommercecluster
üîó Puerto: 27017
==================================================
üöÄ SERVIDOR E-COMMERCE INICIADO
==================================================
üì° Puerto: 5000
üåê URL: http://localhost:5000
üìä API Productos: http://localhost:5000/api/products
üë• API Usuarios: http://localhost:5000/api/users
üõí API √ìrdenes: http://localhost:5000/api/orders
‚ù§Ô∏è  Health Check: http://localhost:5000/health
üìà DB Info: http://localhost:5000/api/db-info
==================================================
‚úÖ Servidor listo para recibir peticiones
```

### **PASO 3.4: Testing completo de APIs**

#### **3.4.1 Probar endpoints de productos**

**En navegador, probar:**

1. **Obtener todos los productos:**
   - URL: http://localhost:5000/api/products
   - Deber√≠a mostrar tus 3 productos con ID num√©rico

2. **Obtener producto individual:**
   - URL: http://localhost:5000/api/products/1
   - Deber√≠a mostrar solo el iPhone

3. **Buscar productos:**
   - URL: http://localhost:5000/api/products/search?q=iPhone
   - Deber√≠a mostrar productos que contengan "iPhone"

#### **3.4.2 Probar frontend**

1. **Ir a:** http://localhost:3000
2. **Verificar que:**
   - ‚úÖ Los productos cargan normalmente
   - ‚úÖ "Ver detalles" funciona
   - ‚úÖ Las im√°genes cargan
   - ‚úÖ El carrito funciona

#### **3.4.3 Probar endpoints de sistema**

1. **Health check:**
   - URL: http://localhost:5000/health
   - Deber√≠a mostrar informaci√≥n del sistema

2. **DB Info:**
   - URL: http://localhost:5000/api/db-info
   - Deber√≠a mostrar conteo de documentos

#### **3.4.4 Probar nuevas funcionalidades con herramientas**

**Si tienes Postman, Thunder Client o similar:**

**1. Crear un producto:**
```json
POST http://localhost:5000/api/products
Content-Type: application/json

{
  "name": "iPad Air M2",
  "description": "La nueva iPad Air con chip M2 ofrece un rendimiento incre√≠ble",
  "price": 799,
  "image": "https://images.unsplash.com/photo-1544244015-0df4b3ffc6b0?w=600",
  "category": "Tablets",
  "features": ["Chip M2", "Pantalla de 10.9 pulgadas", "C√°maras avanzadas"],
  "stock": 12,
  "rating": 4.6,
  "reviewCount": 89
}
```

**2. Registrar usuario:**
```json
POST http://localhost:5000/api/users/register
Content-Type: application/json

{
  "name": "Juan P√©rez",
  "email": "juan@test.com",
  "password": "123456",
  "phone": "+57 300 123 4567"
}
```

---

## ‚úÖ VERIFICACI√ìN FINAL PARTE 3

### **CHECKLIST DE COMPLETACI√ìN:**

#### **‚úÖ Controllers Creados:**
- [ ] ‚úÖ `controllers/productController.js` con m√©todos CRUD
- [ ] ‚úÖ `controllers/userController.js` con autenticaci√≥n
- [ ] ‚úÖ `controllers/orderController.js` con sistema de pedidos

#### **‚úÖ Rutas Organizadas:**
- [ ] ‚úÖ `routes/productRoutes.js` con endpoints REST
- [ ] ‚úÖ `routes/userRoutes.js` con registro/login
- [ ] ‚úÖ `routes/orderRoutes.js` con gesti√≥n de √≥rdenes

#### **‚úÖ Middleware Implementado:**
- [ ] ‚úÖ `middleware/errorHandler.js` con manejo profesional de errores
- [ ] ‚úÖ Logging de peticiones implementado
- [ ] ‚úÖ Validaci√≥n de datos en controllers

#### **‚úÖ Servidor Profesional:**
- [ ] ‚úÖ `server.js` con arquitectura organizada
- [ ] ‚úÖ Rutas modulares conectadas
- [ ] ‚úÖ Middleware de error configurado
- [ ] ‚úÖ Compatibilidad con frontend preservada

#### **‚úÖ Funcionalidad Verificada:**
- [ ] ‚úÖ Frontend carga productos correctamente
- [ ] ‚úÖ P√°gina de detalles funciona
- [ ] ‚úÖ APIs REST responden correctamente
- [ ] ‚úÖ B√∫squeda de productos funciona
- [ ] ‚úÖ Manejo de errores implementado

### **COMANDOS DE VERIFICACI√ìN FINAL:**

```bash
# 1. Verificar estructura
ls -la controllers/ routes/ middleware/

# 2. Verificar servidor corriendo
curl http://localhost:5000/health

# 3. Verificar productos API
curl http://localhost:5000/api/products

# 4. Verificar b√∫squeda
curl "http://localhost:5000/api/products/search?q=iPhone"

# 5. Verificar frontend
# Abrir http://localhost:3000 y probar navegaci√≥n
```

---

## üéâ FELICITACIONES - MANUAL 3 PARTE 3 COMPLETADO

**üèÜ ARQUITECTURA PROFESIONAL IMPLEMENTADA:**

### **ANTES:**
- ‚ùå Un solo archivo server-simple.js
- ‚ùå C√≥digo mezclado y desorganizado
- ‚ùå Sin estructura escalable
- ‚ùå Manejo b√°sico de errores

### **DESPU√âS:**
- ‚úÖ **Arquitectura MVC** profesional implementada
- ‚úÖ **Controllers** organizados por funcionalidad
- ‚úÖ **Rutas modulares** f√°ciles de mantener
- ‚úÖ **Middleware** personalizado de errores
- ‚úÖ **APIs REST** completas y documentadas
- ‚úÖ **Escalabilidad** preparada para crecimiento

### **FUNCIONALIDADES NUEVAS AGREGADAS:**
- **üîç B√∫squeda de productos** con filtros
- **üë§ Sistema de usuarios** con registro/login
- **üõí Sistema de √≥rdenes** completo
- **üìä Estad√≠sticas** y analytics b√°sicas
- **üõ°Ô∏è Manejo robusto** de errores y validaciones

### **ESTRUCTURA FINAL LOGRADA:**
```
üèóÔ∏è ARQUITECTURA PROFESIONAL
‚îú‚îÄ‚îÄ üìÅ controllers/     (L√≥gica de negocio)
‚îú‚îÄ‚îÄ üìÅ routes/          (Endpoints organizados)
‚îú‚îÄ‚îÄ üìÅ middleware/      (Funciones intermedias)
‚îú‚îÄ‚îÄ üìÅ models/          (Modelos de datos)
‚îî‚îÄ‚îÄ üìÑ server.js        (Servidor principal)
```

---

## üìã PREPARACI√ìN PARA PARTE 4

### **MANUAL 3 - PARTE 4: AUTENTICACI√ìN JWT Y SEGURIDAD**
**Lo que viene a continuaci√≥n:**
- ‚úÖ **Autenticaci√≥n JWT** completa
- ‚úÖ **Middleware de protecci√≥n** de rutas
- ‚úÖ **Roles y permisos** (user/admin)
- ‚úÖ **Seguridad avanzada** (rate limiting, CORS)
- ‚úÖ **Integraci√≥n con frontend** para login/logout

### **YA TIENES PREPARADO:**
- ‚úÖ **Controllers de usuario** con login/register
- ‚úÖ **Modelos con encriptaci√≥n** de passwords
- ‚úÖ **Rutas organizadas** para expansi√≥n
- ‚úÖ **Estructura escalable** para autenticaci√≥n

---

**üíæ MANUAL 3 - PARTE 3: CONTROLLERS Y RUTAS COMPLETADO** ‚úÖ

**Estado:** ‚úÖ Arquitectura profesional implementada sin errores  
**Tiempo invertido:** ~60 minutos  
**Nivel alcanzado:** Backend profesional con APIs REST  
**Pr√≥ximo paso:** Implementar autenticaci√≥n JWT y seguridad  

**üöÄ ¬°EXCELENTE TRABAJO! Has transformado tu proyecto en una aplicaci√≥n de nivel empresarial.** üèÜ